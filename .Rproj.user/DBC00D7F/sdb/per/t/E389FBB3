{
    "collab_server" : "",
    "contents" : "\n\n\ntvvarGAM <- function(data, # the n x p data matrix\n                     nb = 10,\n                     consec,\n                     SIMdata,\n                     simulated = FALSE,\n                     plot = FALSE,\n                     estimates = TRUE,\n                     pbar){ #data is the data,nt is the number of time points, nv=number of variables and k is the number of knots\n\n\n\n  # --------- Fill in defaults ---------\n\n  if(missing(pbar)) pbar <- TRUE\n  if(missing(consec)) consec <- 1:nrow(data) # if not provided, assume all measurements are subsequent\n\n  # --------- Compute Aux Variables ---------\n\n  nt <- nrow(data)\n  nv <- ncol(data)\n  tt=1:nt\n\n\n  # --------- Case I: estimates = TRUE ---------\n\n  if(estimates==TRUE) {\n\n\n    Results_GAM<-array(NA,c(c(nv+1,nv),nt,3))\n\n\n    #%##########################################%###\n    ####  Part 1: creating the data #############\n    #%##########################################%##\n    #The functions in this part are created in the file (source code for simulation article 3.R)\n\n    y <- data\n\n    #%##########################################%###\n    ####  Part 2: ESTIMATING GAM##### #############\n    #%##########################################%##\n\n    mod_all <- tvvarGAM(data = y,\n                        nb = nb,\n                        SIMdata = FALSE,\n                        simulated = FALSE,\n                        plot = FALSE,\n                        estimates = FALSE,\n                        pbar = TRUE)\n\n    for (ii in 1:nv){\n\n      mod <- mod_all[[ii]]\n\n      mat_dat<-matrix(c(tt,rep(rep(1,nt),nv)),length(tt),nv+1)\n      coln_Data<-paste(\"y\",1:nv,\"L\",sep=\"\")\n      coln_Data_full<-c(\"tt\",coln_Data)\n      colnames(mat_dat)<-coln_Data_full\n      newd<-as.data.frame(mat_dat)\n      Xp=predict(mod,newd,type=\"lpmatrix\",seWithMean = TRUE)\n      kdim=dim(Xp)[2]/c(nv+1)\n      newpre=predict(mod,new.data=newd,type=\"terms\",se=TRUE)\n      Results_GAM[1,ii,1:nt,2]<-Xp[,1:kdim]%*% coef(mod)[1:kdim]#basis functions intercept!\n\n      Numbrep=5000\n      modr<-mvrnorm(Numbrep,coef(mod),mod$Vp+diag((nv+1)*kdim)*10^(-30))\n\n      #The confidence intervals\n      int.ci<-matrix(NA,nt,Numbrep)\n      for (m in 1:Numbrep){\n        int.ci[,m]<-  Xp[,1:kdim]%*%modr[m,1:kdim]\n      }\n\n      Results_GAM[1,ii,1:nt,1]<-apply(int.ci,1,quantile,c(.975))\n      Results_GAM[1,ii,1:nt,3]<-apply(int.ci,1,quantile,c(.025))\n\n\n      for (j in 1:nv){\n        Results_GAM[j+1,ii,1:nt,2]<-Xp[,(j*kdim+1):((j+1)*kdim)]%*% coef(mod)[(j*kdim+1):((j+1)*kdim)]\n\n        #The confidence intervals\n        phi.ci<-matrix(NA,nt,Numbrep)\n        for (m in 1:Numbrep){\n          phi.ci[,m]<-Xp[,(j*kdim+1):((j+1)*kdim)]%*%modr[m,(j*kdim+1):((j+1)*kdim)]\n        }\n        Results_GAM[j+1,ii,1:nt,1]<-apply(phi.ci,1,quantile,c(.975))\n        Results_GAM[j+1,ii,1:nt,3]<-apply(phi.ci,1,quantile,c(.025))\n      }\n\n\n      outlist<-list('Estimate'=Results_GAM[, , , 2],'CI_low'=Results_GAM[, , , 3],'CI_high'=Results_GAM[, , , 1])\n\n    }\n    return(Results_GAM=outlist)\n\n\n\n    # --------- Case I: estimates = FALSE ---------\n\n  } else {\n\n\n\n    # Lag data by Laura\n\n    Data1=matrix(0,nt,(nv*2),byrow=T)\n    for (h in (nv+1):(nv*2)){\n      Data1[,(h-nv)]=data[,(h-nv)]# data wordt hier gelagged\n\n      Data1[,h]=c(NA,data[1:(nt-1),(h-nv)])# data wordt hier gelagged\n    }\n\n    Data1=as.data.frame(Data1)\n    colnames(Data1)=c(paste(\"y\",1:nv,sep=\"\"),paste(\"y\",1:nv,\"L\",sep=\"\"))\n\n\n    # Instead use lagData() from the mgm package\n\n    lagD_obj <- mgm:::lagData(data,\n                              lags = 1,\n                              consec = consec)\n\n\n    # Back to Laura's variable names:\n    Data2 <- cbind(lagD_obj$data_response, lagD_obj$l_data_lags[[1]])\n    Data2 <- rbind(rep(NA, ncol(Data2)), Data2) # to make Laura's code below work\n    Data2 <- as.data.frame(Data2)\n    colnames(Data2)=c(paste(\"y\",1:nv,sep=\"\"),paste(\"y\",1:nv,\"L\",sep=\"\"))\n    Data1 <- Data2\n\n    coln=colnames(Data1)[1:nv]\n    colnL=colnames(Data1)[(nv+1):(nv*2)]\n    allcol2=c()\n\n\n    for(i in 1:nv){allcol2[i]=paste(\"s(tt,by=\",colnL[i],\",k=nb\",\")\",sep=\"\")}\n    allcol3=paste(allcol2,collapse=\"+\")\n\n\n    # Progress bar\n    if(pbar==TRUE) pb <- txtProgressBar(min = 0, max=nv, initial=0, char=\"-\", style = 3)\n\n    model=list()\n    for (j in 1:nv){\n\n      ff <- as.formula(paste(coln[j],\" ~ \",\"s(tt,k=nb)\",\"+\",allcol3))\n      model[[j]]<-gam(ff,data=Data1,seWithMean=TRUE)\n\n      # Update Progress Bar\n      if(pbar==TRUE) setTxtProgressBar(pb, j)\n\n\n    }\n\n\n\n\n\n\n\n\n\n    # --------- Plotting Stuff ---------\n\n\n    if(plot==TRUE & simulated==TRUE){\n      par(mfrow=c(nv,(nv+1)))\n      tt=1:nt\n      for (i in 1:nv){\n        mod<-model[[i]]\n        k=0\n\n        for ( j in 1:(nv+1))\n          if(j==1)\n          {plot.gam(mod,seWithMean = TRUE,select=1,rug=F,shift=coef(mod)[1],ylab=\"intercept\")\n            lines(tt,SIMdata$aint[,i],col=\"red\")\n          }\n        else {plot.gam(mod,seWithMean = TRUE,select=j,rug=F,ylim=c(-1,1))\n          k=1+k\n\n          lines(tt,SIMdata$rho[,k],col=\"red\")\n\n        }\n      }\n    }  else if (plot==TRUE) {  par(mfrow=c(nv,(nv+1)))\n      for (i in 1:nv){\n        mod<-model[[i]]\n        k=0\n\n        for ( j in 1:(nv+1))\n          if(j==1)\n          {plot.gam(mod,seWithMean = TRUE,select=1,rug=F,shift=coef(mod)[1],ylab=\"intercept\")\n          }\n        else {plot.gam(mod,seWithMean = TRUE,select=j,rug=F,ylim=c(-1,1))\n          k=1+k\n\n\n        }\n      }\n    } else {\n\n\n      # Return Estimates\n\n      return(model)\n\n    }\n\n  }\n}\n\n\n",
    "created" : 1502375570482.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1167270440",
    "id" : "E389FBB3",
    "lastKnownWriteTime" : 1502378829,
    "last_content_update" : 1502378829438,
    "path" : "/Volumes/Macintosh HD 2/Dropbox/MyData/_PhD/__software/tvvarGAM/R/tvvarGAM.R",
    "project_path" : "R/tvvarGAM.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}